.\" This is free and unencumbered software released into the public domain.
.\"
.\" Anyone is free to copy, modify, publish, use, compile, sell, or distribute
.\" this software, either in source code form or as a compiled binary, for any
.\" purpose, commercial or non-commercial, and by any means.
.\"
.\" In jurisdictions that recognize copyright laws, the author or authors of
.\" this software dedicate any and all copyright interest in the software to the
.\" public domain. We make this dedication for the benefit of the public at
.\" large and to the detriment of our heirs and successors. We intend this
.\" dedication to be an overt act of relinquishment in perpetuity of all present
.\" and future rights to this software under copyright law.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
.\" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
.\" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
.\" AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
.\" ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
.\" WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
.Dd March 24, 2025
.Dt NVXX 3
.Os
.Sh NAME
.Nm nvxx
.Nd C++ interface for
.Xr nv 9
.Sh LIBRARY
.Lb libnvxx
.Sh SYNOPSIS
.In nvxx.h
.\" unfortunately, mdoc is not really set up for documenting C++ classes.
.Bd -literal
namespace bsd {

// exposition only
struct nv_error : std::runtime_error {
};

// exposition only
struct nv_error_state : nv_error {
	std::error_code error;
};

// exposition only
struct nv_key_not_found : nv_error {
	std::string key;
};

// exposition only
struct nv_key_exists : nv_error {
	std::string key;
};

// exposition only
template<typename T>
using container-type = ...;

// exposition only
struct const_nv_list : <unspecified> {
	const_nv_list();
	explicit const_nv_list(::nvlist_t const *);
	const_nv_list(const_nv_list const &);

	const_nv_list &operator=(const_nv_list const &);
	const_nv_list &operator=(nv_list const &);

	::nvlist_t const *ptr() const;

	void dump(int fd) const;
	void fdump(std::FILE *fp) const;

	std::size_t packed_size() const;
	std::vector<std::byte> pack() const;

	std::error_code error() const;

	explicit operator bool() const;

	bool empty() const;
	int flags() const;
	bool in_array() const;

	void send(int fd) const;

	bool exists(std::string_view key) const;
	bool exists_null(std::string_view key) const;
	bool exists_bool(std::string_view key) const;
	bool exists_number(std::string_view key) const;
	bool exists_string(std::string_view key) const;
	bool exists_binary(std::string_view key) const;
	bool exists_nvlist(std::string_view key) const;
	bool exists_descriptor(std::string_view key) const;

	auto get_bool(std::string_view key) const -> bool;
	auto get_number(std::string_view key) const -> std::uint64_t;
	auto get_string(std::string_view key) const -> std::string_view;
	auto get_descriptor(std::string_view key) const -> int;
	auto get_nvlist(std::string_view key) const -> const_nv_list;

	// exposition only
	auto get_binary(std::string_view key) const -> container-type<std::byte const>;

	bool exists_bool_array(std::string_view key) const;
	bool exists_number_array(std::string_view key) const;
	bool exists_string_array(std::string_view key) const;
	bool exists_descriptor_array(std::string_view key) const;
	bool exists_nvlist_array(std::string_view key) const;

	// exposition only
	auto get_bool_array(std::string_view key) const -> container-type<bool const>;
	auto get_number_array(std::string_view key) const -> container-type<std::uint64_t const>;
	auto get_string_array(std::string_view key) const -> container-type<std::string_view>;
	auto get_descriptor_array(std::string_view key) const -> container-type<int const>;
	auto get_nvlist_array(std::string_view key) const -> container-type<const_nv_list>;
};

// exposition only
struct nv_list : <unspecified> {
	explicit nv_list(int flags = 0);
	explicit nv_list(::nvlist_t *);
	nv_list(nv_list const &);
	nv_list(nv_list &&);

	nv_list &operator=(nv_list const &);
	nv_list &operator=(nv_list &&);

	::nvlist_t *ptr();
	::nvlist_t const *ptr() const;

	::nvlist_t *release() &&;

	void set_error(int error);

	void free(std::string_view name);

	operator const_nv_list() const;

	void add_null(std::string_view key);
	void add_bool(std::string_view key, bool value);
	void add_number(std::string_view key, std::uint64_t);
	void add_string(std::string_view key, std::string_view);
	void add_descriptor(std::string_view key, int);
	void add_nvlist(std::string_view key, const_nv_list const &);
	void add_binary(std::string_view key, std::span<std::byte const>);

	void move_string(std::string_view key, char *);
	void move_descriptor(std::string_view key, int);
	void move_binary(std::string_view key, std::span<std::byte>);
	void move_nvlist(std::string_view key, nv_list &&);
	void move_nvlist(std::string_view key, ::nvlist_t *);

	void free_null(std::string_view key);
	void free_bool(std::string_view key);
	void free_number(std::string_view key);
	void free_string(std::string_view key);
	void free_descriptor(std::string_view key);
	void free_binary(std::string_view key);
	void free_nvlist(std::string_view key);

	auto take_bool(std::string_view key) -> bool;
	auto take_number(std::string_view key) -> std::uint64_t;
	auto take_string(std::string_view key) -> std::string;
	auto take_descriptor(std::string_view key) -> int;
	auto take_nvlist(std::string_view key) -> nv_list;

	void move_bool_array(std::string_view key, std::span<bool>);
	void move_number_array(std::string_view key, std::span<std::uint64_t>);
	void move_string_array(std::string_view key, std::span<char *>);
	void move_descriptor_array(std::string_view key, std::span<int>);
	void move_nvlist_array(std::string_view key, std::span<::nvlist_t *>);

	void append_bool_array(std::string_view key, bool);
	void append_number_array(std::string_view key, std::uint64_t);
	void append_string_array(std::string_view key, std::string_view);
	void append_descriptor_array(std::string_view key, int);
	void append_nvlist_array(std::string_view key, const_nv_list const &);

	void free_bool_array(std::string_view key);
	void free_number_array(std::string_view key);
	void free_string_array(std::string_view key);
	void free_nvlist_array(std::string_view key);
	void free_descriptor_array(std::string_view key);

	void add_bool_array(std::string_view key, std::span<bool const>);
	void add_number_array(std::string_view key, std::span<std::uint64_t const>);
	void add_string_array(std::string_view key, std::span<std::string_view const>);
	void add_descriptor_array(std::string_view key, std::span<int const>);
	void add_nvlist_array(std::string_view key, std::span<const_nv_list const>);
	void add_nvlist_array(std::string_view key, std::span<nv_list const>);

	// exposition only

	template<std::ranges::range Range>
	void add_bool_range(std::string_view key, Range &&);

	template<std::ranges::range Range>
	void add_number_range(std::string_view key, Range &&);

	template<std::ranges::range Range>
	void add_binary_range(std::string_view key, Range &&);

	template<std::ranges::range Range>
	void add_string_range(std::string_view key, _Range &&);

	template<std::ranges::range Range>
	void add_descriptor_range(std::string_view key, _Range &&);

	// exposition only
	auto take_bool_array(std::string_view key) -> container-type<bool>;
	auto take_number_array(std::string_view key) -> container-type<std::uint64_t>;
	auto take_string_array(std::string_view key) -> container-type<std::string>;
	auto take_nvlist_array(std::string_view key) -> container-type<nv_list>;
	auto take_descriptor_array(std::string_view __key) -> container-type<int>;
	auto take_binary(std::string_view key) -> container-type<std::byte>;
};

} // namespace bsd
.Ed
.Sh DESCRIPTION
The
.Nm
library provides a C++ wrapper around the
.Xr nv 9
C library.
The library is ABI compatible with the C library, in the sense that it can both
consume and produce pointers of type
.Vt nvlist_t .
.Sh TYPES
The library provides two basic types:
.Vt nv_list ,
which represents an owning, mutable
.Vt nvlist_t * ,
and
.Vt const_nv_list ,
which represents a non-owning, immutable
.Vt const nvlist_t * .
.Pp
A
.Vt const_nv_list
provides all non-mutating operations on the nvlist, such as testing for the
existence of a key, fetching a key, and packing or sending an nvlist.
A
.Vt const_nv_list
can be constructed from an existing
.Vt const nvlist_t * ,
or from an
.Vt nv_list ,
or copy-constructed from another
.Vt const_nv_list .
Because
.Vt const_nv_list
is non-owning, it always refers to an existing nvlist and will never destroy
the object to which it refers; this is the responsibility of the user.
.Pp
An
.Vt nv_list
provides all the operations that
.Vt const_nv_list
provides, plus additional mutating operations such as adding or removing keys.
An
.Vt nv_list
can be constructed from an existing
.Vt nvlist_t * ,
in which case it will take ownership of the nvlist.
It may also be copy-constructed from another
.Vt nv_list
or
.Vt const_nv_list ,
in which case it will duplicate the underlying list using
.Xr nvlist_clone 3 ,
and it may be default-constructed, in which case it will create a new nvlist
using
.Xr nvlist_create 3 .
To pass flags to
.Xr nvlist_create 3 ,
use the optional
.Fa "int flags"
argument to the constructor.
.Pp
Both
.Vt const_nv list
and
.Vt nv_list
support copy-initialization and exception-free move-initialization.
In addition,
.Vt nv_list
supports default-initialization.
.Sh ERROR HANDLING
The library defines a base error class called
.Vt nv_error ,
which is thrown when an error is detected.
Several more specific derived exception types are defined:
.Bl -tag -width indent
.It Vt nv_error_state
Thrown when attempting to perform an operation on an nvlist which is in the
error state, such as adding or removing a key.
This is also thrown when attempting to construct an
.Vt nv_list
or
.Vt const_nv_list
using an
.Vt nvlist_t *
which is in the error state.
.It Vt nv_key_not_found
Thrown when an attempt is made to fetch a key which does not exist in the
nvlist.
.It Vt nv_key_exists
Thrown when an attempt is made to add a key to an nvlist when a key of the same
name is already present, and the list does permit duplicates.
.El
.Sh CONST_NV_LIST OPERATIONS
The
.Fn dump
and
.Fn fdump
member functions write the contents of the nvlist to the provided file
descriptor or file pointer in a human-readable format.
These functions are intended for debugging; the output format should not be
considered stable.
.Pp
The
.Fn error
member function returns the current error code of the nvlist.
If the nvlist is not in an error state, a default-initialized
.Fn std::error_code
is returned.
.Pp
The
.Fn "operator bool"
member function returns
.Dv false
if the nvlist is in an error state, otherwise
.Dv true .
.Pp
The
.Fn empty
member function returns
.Dv true
if the nvlist is empty, i.e. it contains no values.
.Pp
The
.Fn flags
member function returns the flags that were used to create this nvlist.
Refer to
.Xr nvlist_create 9
for documentation on the flags that may be set here.
.Pp
.Fn
The
.Fn pack
member function serializes the nvlist to a byte stream and returns it.
The byte stream can later be passed to
.Fn nv_list::unpack
to turn it back into an nvlist.
.Pp
The
.Fn packed_size
member function returns the number of bytes that would be generated by
.Fn pack .
.Pp
The
.Fn send
function packs the contents of the nvlist as if by
.Fn pack ,
and sends the resulting byte stream over the given file descriptor.
If the nvlist is in the error state, an exception of type
.Vt nv_error_state
is thrown.
If an operating system error occurs while writing to the file descriptor,
an exception of type
.Vt std::system_error
is thrown.
.Pp
The
.Fn exists
member function returns
.Dv true
if a key by the given name exists, otherwise
.Dv false .
.Pp
The 
.Fn exists_null ,
.Fn exists_bool ,
.Fn exists_number ,
.Fn exists_string ,
.Fn exists_nvlist ,
.Fn exists_binary ,
.Fn exists_bool_array ,
.Fn exists_number_array ,
.Fn exists_string_array ,
.Fn exists_nvlist_array
and
.Fn exists_descriptor_array 
member functions return
.Dv true
if a key with the given name exists in the nvlist, or otherwise
.Dv false .
These functions may be called on an nvlist which is in the error state.
.Pp
The
.Fn get_bool ,
.Fn get_number ,
.Fn get_string ,
.Fn get_nvlist ,
.Fn get_descriptor ,
.Fn get_binary ,
.Fn get_bool_array ,
.Fn get_number_array ,
.Fn get_string_array ,
.Fn get_nvlist_array
and
.Fn get_descriptor_array
member functions return the value of the key by the given name in the nvlist.
If a key by that name does not exist, then an exception of type
.Vt nv_key_not_found
is thrown.
For the array variants, the return type
.Vt container-type<T>
is defined to be an unspecified container type
.Vt C
which fulfills the requirements of
.Vt std::ranges::continguous_range
and where
.Vt std::ranges::range_value_t<C>
is equal to
.Vt T .
.Sh NV_LIST OPERATIONS
The
.Fn add_null ,
.Fn add_bool ,
.Fn add_number ,
.Fn add_string  and
.Fn add_nvlist
and
.Fn add_binary
member functions add a new key to the nvlist of the appropriate type with the
given name.
If a value of the given name is already present in the nvlist, and the nvlist
does not permit duplicate value names, then an exception of type
.Vt nv_key_exists
is thrown, and the nvlist is placed in the error state.
.Pp
The
.Fn add_descriptor
member function adds a new file descriptor to the nvlist with the given name.
The file descriptor will be duplicated using
.Xr dup 2
prior to being added, and if later removed, will be closed using
.Xr close 2 .
The behaviour when attempting to add a duplicate value name is the same as
described for the other
.Fn add_
member functions.
.Pp
The
.Fn add_bool_array ,
.Fn add_number_array ,
.Fn add_string_array ,
.Fn add_nvlist_array
and
.Fn add_descriptor_array
functions add an array of that type to the nvlist.
The array should be provided as an
.Vt std::span<>
of the appropriate type; the value type of the span may be
.Vt const .
The behaviour when attempting to add a duplicate value name is the same as
described for the
.Fn add_
member functions.
.Pp
The
.Fn add_bool_range ,
.Fn add_number_range ,
.Fn add_string_range ,
.Fn add_nvlist_range
and
.Fn add_descriptor_range
functions add an array of that type to the nvlist, where the contents of the
array are provided as a type which fulfills the requirements of
.Vt std::ranges::range .
The value type of the range may be
.Vt const .
The behaviour when attempting to add a duplicate value name is the same as
described for the
.Fn add_
member functions.
.Pp
The
.Fn free_null ,
.Fn free_bool ,
.Fn free_number ,
.Fn free_string ,
.Fn free_nvlist ,
.Fn free_descriptor ,
.Fn free_binary ,
.Fn free_bool_array ,
.Fn free_number_array ,
.Fn free_string_array ,
.Fn free_nvlist_array
and
.Fn free_descriptor_array
member functions remove the first value of the given name of the appropriate
type from the nvlist.
If no suitable value is found to remove, an exception of type
.Vt nv_key_not_found
is thrown.
.Pp
The
.Fn take_null ,
.Fn take_bool ,
.Fn take_number ,
.Fn take_string ,
.Fn take_nvlist ,
.Fn take_descriptor ,
.Fn take_binary ,
.Fn take_bool_array ,
.Fn take_number_array ,
.Fn take_string_array ,
.Fn take_nvlist_array
and
.Fn take_descriptor_array
member functions remove the first value of the given name of the appropriate
type from the nvlist, and return the value which was removed.
If no suitable value is found to remove, an exception of type
.Vt nv_key_not_found
is thrown.
.Pp
The
.Fn move_string
member function takes ownership of the provided string pointer, which must be a
NUL-terminated C string allocated using
.Fn std::malloc ,
and adds it to the nvlist.
The string will later be freed using
.Fn std::free .
The behaviour when attempting to add a duplicate value name is the same as
described for the
.Fn add_
member functions.
.Pp
The
.Fn move_nvlist
member function takes ownership of the provided nvlist and adds it to the
nvlist.
The behaviour when attempting to add a duplicate value name is the same as
described for the
.Fn add_
member functions.
.Pp
The
.Fn move_descriptor
member function takes ownership of the provided file descriptor and adds it to
the nvlist.
This equivalent to calling
.Fn add_descriptor ,
except that the file descriptor is not duplicated.
.Pp
The
.Fn move_bool_array ,
.Fn move_number_array ,
.Fn move_string_array ,
.Fn move_nvlist_array
and
.Fn move_descriptor_array
member functions take ownership of the provided C array of the given type
and add it to the nvlist as an array.
The array must be a C array which was previously allocated using
.Fn std::malloc .
In the case of
.Fn move_string_array
and
.Fn move_nvlist_array ,
the nvlist takes ownership of the member values and will later free them using
.Fn std::free
(for strings) or
.Xr nvlist_destroy 3
(for nvlists).
In the case of
.Fn move_descriptor_array ,
the nvlist takes ownership of the member descriptors and will later close them
using
.Xr close 2 .
